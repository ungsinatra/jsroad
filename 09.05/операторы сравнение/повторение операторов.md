Повторение сравнительных операторов

Все операторы сравнении возвращают true/false

let result = 5 > 4; // результат сравнения присваивается переменной result
alert( result ); // true


#Знаки больше и меньше “>””<”
При сравнении разных типов,они конвертируют в число

alert( '2' > 1 ); // true, строка '2' становится числом 2
alert( '01' <1 ); // false, строка '01' становится числом 1

Главное запомнить,что False при переводе к числу дает 0,true=1

let a = 0;
alert( Boolean(a) ); // false

let b = "0";
alert( Boolean(b) ); // true(потому что пустая строка равно false)

alert(a == b); // true!(тут разные типы приводятся к числу(0==0)-true)

Операторы сравнение “==” и “===”
Отличие == от === в том что оператор”==” - если сравниваются разные типы данных,то он приведет к число 

alert( 0 == false ); // true(так как false при приведении к числу даст 0)

alert( ‘’'' == false ); // true (тоже самое что и выше(0==0))

#Операторы сравнение “==” и “===”


#Отличие == от === в том что оператор”==” - если сравниваются разные типы данных,то он приведет к число 

alert( 0 == false ); // true(так как false при приведении к числу даст 0)

alert( ‘’'' == false ); // true (тоже самое что и выше(0==0))


Оператор “===” - смотрит в первую очередь на типы,если они одинаковые,то потом сравнивает,иначе сразу false

Ещё есть оператор строгого неравенства !==, аналогичный !=.


#Сравнение с null и undefined

alert( null === undefined ); // false так как у них разные типы данных

alert( null == undefined ); // true так как при переводе к числу они дают нули 

При использовании операторов больше и меньше 

Значения null/undefined преобразуются к числам: null становится 0, а undefined – NaN.

какая-то хуйня!
alert( null > 0 );  // (1) false
alert( null == 0 ); // (2) false
alert( null >= 0 ); // (3) true

Несравненное значение undefined

alert( undefined > 0 ); // false (1) так как undefinde при переводе к числу дасть NaN поэту false
alert( undefined < 0 ); // false (2)так как undefinde при переводе к числу дасть NaN поэту false
alert( undefined == 0 ); // false (3)Нестрогое равенство (3) возвращает false, потому что undefined равно только null, undefined и ничему больше.



NaN  
является неравным (посредством сравнения через ==, !=, ===, and !==) любому другому значению, включая другое значение NaN. Используйте Number.isNaN() или isNaN()

NaN === NaN;        // false
Number.NaN === NaN; // false
isNaN(NaN);         // true
isNaN(Number.NaN);  // true

function valueIsNaN(v) { return v !== v; }
valueIsNaN(1);          // false
valueIsNaN(NaN);        // true
valueIsNaN(Number.NaN); // true

